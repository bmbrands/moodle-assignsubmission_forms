{"version":3,"file":"fieldmanager.min.js","sources":["../src/fieldmanager.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * TODO describe module fieldmanager\n *\n * @module     assignsubmission_forms/fieldmanager\n * @copyright  2025 Bas Brands <bas@sonsbeekmedia.nl>, Jonas Rehkopp <jonas.rehkopp@polizei.nrw.de>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Templates from 'core/templates';\n\n/**\n * The FieldManager class provides methods to manage fields in the forms repository.\n * It allows for fetching and updating field data.\n */\nclass FieldManager {\n\n    /**\n     * The fields data.\n     * @type {Array}\n     */\n    fields = [];\n\n    /**\n     * The field types available in the forms repository.\n     * @type {Array}\n     */\n    fieldtypes = [];\n\n    /**\n     * Initializes the FieldManager.\n     */\n    constructor() {\n        const rootElement = document.querySelector('[data-region=\"forms-fieldmanager\"]');\n        const form = document.querySelector('form[action=\"modedit.php\"]');\n        const fieldtypesInput = document.querySelector('[name=\"assignsubmission_forms_fieldtypes\"]');\n        if (!rootElement || !form || !fieldtypesInput) {\n            throw new Error('Required elements not found in the DOM.');\n        }\n        // Parse the fieldtypes from the input value.\n        try {\n            this.fieldtypes = JSON.parse(fieldtypesInput.value);\n        } catch (e) {\n            throw new Error('Failed to parse fieldtypes from input value: ' + e.message);\n        }\n        this.renderFields();\n\n        rootElement.addEventListener('click', (e) => {\n            let btn = e.target.closest('[data-action]');\n            if (btn) {\n                e.preventDefault();\n                this.actions(btn);\n            }\n        });\n        form.addEventListener('input', async(e) => {\n            let input = e.target.closest('.forms-fieldmanager input');\n            if (input) {\n                // If the input is a field name, we need to save the fields.\n                await this.saveFields();\n            }\n            let select = e.target.closest('.forms-fieldmanager select');\n            if (select) {\n                // If the select is a field type, we need to save the fields.\n                await this.saveFields();\n            }\n            let requiredButton = e.target.closest('input[name=\"fieldrequired\"]');\n            if (requiredButton) {\n                // If the required button is clicked, we need to save the fields.\n                await this.saveFields();\n            }\n            let tabName = e.target.closest('input[data-action=\"update-tab-name\"]');\n            if (tabName) {\n                // If the tab name input is changed, we need to save the fields.\n                await this.saveFields();\n            }\n        });\n    }\n\n    /**\n     * Actions to be performed when a button is clicked.\n     * @param {HTMLElement} btn The button that was clicked.\n     * @returns {Promise<void>} A promise that resolves when the action is complete.\n     */\n    async actions(btn) {\n        const actionMap = {\n            'add-field': this.addField,\n            'save-fields': this.saveFields,\n            'delete-field': this.deleteField,\n            'add-tab': this.addTab,\n            'remove-tab': this.removeTab,\n        };\n        const action = btn.dataset.action;\n        if (actionMap[action]) {\n            actionMap[action].call(this, btn);\n        }\n    }\n\n    /**\n     * Set the configuration for the field manager.\n     * @param {Object} fields The configuration object.\n     */\n    setConfig(fields) {\n        const config = document.querySelector('[name=\"assignsubmission_forms_config\"]');\n        if (!config) {\n            throw new Error('Configuration input not found.');\n        }\n        // Convert the fields array to a JSON string and set it as the value of the config input.\n        config.value = JSON.stringify(fields);\n    }\n\n    /**\n     * Get the configuration for the field manager.\n     * @returns {Object} fields The configuration object.\n     */\n    getConfig() {\n        const config = document.querySelector('[name=\"assignsubmission_forms_config\"]');\n        if (!config) {\n            throw new Error('Configuration input not found.');\n        }\n        if (!config.value) {\n            this.addField(); // If no config value, add a new field.\n            return;\n        }\n        // Parse the JSON string from the config input and return it as an object.\n        const fields = JSON.parse(config.value);\n        if (!fields || !Array.isArray(fields) || fields.length === 0) {\n            this.addField();\n        } else {\n            this.fields = fields;\n        }\n    }\n\n    /**\n     * Fetch the field data from the UI\n     */\n    getFieldsFromUI() {\n        const rootElement = document.querySelector('[data-region=\"forms-fieldmanager\"]');\n        if (!rootElement) {\n            throw new Error('FieldManager root element not found.');\n        }\n        const fieldCards = rootElement.querySelectorAll('[data-region=\"field\"]');\n        if (fieldCards.length === 0) {\n            return []; // No fields found, return an empty array.\n        }\n        // Collect the fields data from the UI.\n        const fields = [];\n        fieldCards.forEach((card) => {\n            const fieldid = card.dataset.fieldid;\n            const nameInput = card.querySelector('input[name=\"fieldname\"]');\n            const typeSelect = card.querySelector('select[name=\"fieldtype\"]');\n            const requiredSelect = card.querySelector('input[name=\"fieldrequired\"]');\n            const tab = rootElement.querySelector('[data-tab-id=\"' + fieldid + '\"]');\n            if (nameInput && typeSelect) {\n                const field = {\n                    id: fieldid ? parseInt(fieldid, 10) : null,\n                    name: nameInput.value.trim(),\n                    type: typeSelect.value,\n                    deleted: card.dataset.deleted == 1 ? true : false,\n                    required: requiredSelect.value == '1' ? true : false,\n                };\n                if (tab) {\n                    const tabNameInput = tab.querySelector('input[data-action=\"update-tab-name\"]');\n                    if (tabNameInput) {\n                        field.tabs = {\n                            id: field.id,\n                            name: tabNameInput.value.trim()\n                        };\n                    }\n                }\n                fields.push(field);\n            } else {\n                throw new Error('Field name or type input not found in the field card.');\n            }\n        });\n        if (fields.length === 0) {\n            throw new Error('No valid fields found in the UI.');\n        }\n        return fields;\n    }\n\n    /**\n     * Saves the fields to the forms repository.\n     * @returns {Promise<void>} A promise that resolves when the fields are saved.\n     */\n    async saveFields() {\n        const rootElement = document.querySelector('[data-region=\"forms-fieldmanager\"]');\n        if (!rootElement) {\n            throw new Error('FieldManager root element not found.');\n        }\n        this.fields = this.getFieldsFromUI();\n        this.setConfig(this.fields); // Set the configuration with the current fields.\n        return; // No need to save fields if assignment ID is -1.\n    }\n\n    /**\n     * Adds a new field to the forms repository.\n     * @returns {Promise<void>} A promise that resolves when the field is added.\n     */\n    async addField() {\n        await this.saveFields(); // Save existing fields before adding a new one.\n        const newField = {\n            name: '',\n            type: 'textarea',\n        };\n\n        this.fields.push(newField);\n        this.renderFields();\n    }\n\n    /**\n     * Deletes a field from the forms repository.\n     * @param {HTMLElement} btn The button that was clicked to delete the field.\n     * @returns {Promise<void>} A promise that resolves when the field is deleted.\n     */\n    async deleteField(btn) {\n        const fieldCard = btn.closest('[data-region=\"field\"]');\n        if (!fieldCard) {\n            throw new Error('Field card not found.');\n        }\n        const fieldId = fieldCard.dataset.fieldid;\n        if (!fieldId) {\n            throw new Error('Field ID not found.');\n        }\n\n        // Remove the field from the fields array.\n        this.fields = this.fields.filter(field => field.id !== parseInt(fieldId, 10));\n        // Re-render the fields.\n        await this.renderFields();\n    }\n\n    /**\n     * Add a tab to separate the fields\n     * @param {HTMLElement} btn The button that was clicked to add the tab.\n     * @returns {Promise<void>} A promise that resolves when the tab is added.\n     */\n    async addTab(btn) {\n        const fieldCard = btn.closest('[data-region=\"field\"]');\n        if (!fieldCard) {\n            throw new Error('Field card not found.');\n        }\n        const fieldId = fieldCard.dataset.fieldid;\n        if (!fieldId) {\n            throw new Error('Field ID not found.');\n        }\n\n        const fieldIndex = this.fields.findIndex(field => field.id === parseInt(fieldId, 10));\n        if (fieldIndex === -1) {\n            throw new Error('Field not found in the fields array.');\n        }\n        const field = this.fields[fieldIndex];\n        field.tabs = field.tabs || [];\n        field.tabs.push({\n            id: fieldId,\n            name: 'New Tab',\n        });\n        await this.renderFields();\n    }\n\n    /**\n     * Remove a tab from a field.\n     * @param {HTMLElement} btn The button that was clicked to remove the tab.\n     * @returns {Promise<void>} A promise that resolves when the tab is removed.\n     */\n    async removeTab(btn) {\n\n        const fieldId = btn.dataset.fieldid;\n        if (!fieldId) {\n            throw new Error('Field ID not found.');\n        }\n\n        const fieldIndex = this.fields.findIndex(field => field.id === parseInt(fieldId, 10));\n        if (fieldIndex === -1) {\n            throw new Error('Field not found in the fields array.');\n        }\n        const field = this.fields[fieldIndex];\n        field.tabs = [];\n        await this.renderFields();\n    }\n\n    /**\n     * Parse the fetched fields data, add the fieldtypes to each field and set the selected type.\n     * @returns {Promise<void>} A promise that resolves when the fields are parsed.\n     */\n    async parseFields() {\n        if (this.fields.length == 0) {\n            this.getConfig();\n        }\n        let fieldcount = 0;\n        // Create a copy of the fieldtypes to avoid modifying the original array.\n        this.fields.forEach((field) => {\n            field.id = ++fieldcount; // Assign a unique ID to each field.\n            const fieldtypes = this.fieldtypes.map(type => structuredClone(type));\n            // Add the selected attribute to the fieldtypes.\n            fieldtypes.forEach((type) => {\n                type.selected = type.name === field.type;\n            });\n            if (!fieldtypes.some(type => type.name === field.type)) {\n                fieldtypes[0].selected = true;\n            }\n            field.fieldtypes = fieldtypes;\n        });\n    }\n\n\n    /**\n     * Renders the fields\n     */\n    async renderFields() {\n        await this.parseFields();\n        const rootElement = document.querySelector('[data-region=\"forms-fieldmanager\"] [data-region=\"fields-container\"]');\n        if (!rootElement) {\n            throw new Error('FieldManager root element not found.');\n        }\n\n        const {html, js} = await Templates.renderForPromise('assignsubmission_forms/fields', {\n            fields: this.fields,\n        });\n        Templates.replaceNodeContents(rootElement, html, js);\n    }\n}\n\nnew FieldManager();\n"],"names":["constructor","rootElement","document","querySelector","form","fieldtypesInput","Error","fieldtypes","JSON","parse","value","e","message","renderFields","addEventListener","btn","target","closest","preventDefault","actions","async","this","saveFields","actionMap","addField","deleteField","addTab","removeTab","action","dataset","call","setConfig","fields","config","stringify","getConfig","Array","isArray","length","getFieldsFromUI","fieldCards","querySelectorAll","forEach","card","fieldid","nameInput","typeSelect","requiredSelect","tab","field","id","parseInt","name","trim","type","deleted","required","tabNameInput","tabs","push","fieldCard","fieldId","filter","fieldIndex","findIndex","fieldcount","map","structuredClone","selected","some","parseFields","html","js","Templates","renderForPromise","replaceNodeContents"],"mappings":"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"}