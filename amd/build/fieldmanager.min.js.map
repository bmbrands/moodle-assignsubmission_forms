{"version":3,"file":"fieldmanager.min.js","sources":["../src/fieldmanager.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * TODO describe module fieldmanager\r\n *\r\n * @module     assignsubmission_forms/fieldmanager\r\n * @copyright  2025 Bas Brands <bas@sonsbeekmedia.nl>, Jonas Rehkopp <jonas.rehkopp@polizei.nrw.de>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nimport Templates from 'core/templates';\r\n\r\n/**\r\n * The FieldManager class provides methods to manage fields in the forms repository.\r\n * It allows for fetching and updating field data.\r\n */\r\nclass FieldManager {\r\n\r\n    /**\r\n     * The fields data.\r\n     * @type {Array}\r\n     */\r\n    fields = [];\r\n\r\n    /**\r\n     * The field types available in the forms repository.\r\n     * @type {Array}\r\n     */\r\n    fieldtypes = [];\r\n\r\n    /**\r\n     * Initializes the FieldManager.\r\n     */\r\n    constructor() {\r\n        const rootElement = document.querySelector('[data-region=\"forms-fieldmanager\"]');\r\n        const form = document.querySelector('form[action=\"modedit.php\"]');\r\n        const fieldtypesInput = document.querySelector('[name=\"assignsubmission_forms_fieldtypes\"]');\r\n        if (!rootElement || !form || !fieldtypesInput) {\r\n            throw new Error('Required elements not found in the DOM.');\r\n        }\r\n        // Parse the fieldtypes from the input value.\r\n        try {\r\n            this.fieldtypes = JSON.parse(fieldtypesInput.value);\r\n        } catch (e) {\r\n            throw new Error('Failed to parse fieldtypes from input value: ' + e.message);\r\n        }\r\n        this.renderFields();\r\n\r\n        rootElement.addEventListener('click', (e) => {\r\n            let btn = e.target.closest('[data-action]');\r\n            if (btn) {\r\n                e.preventDefault();\r\n                this.actions(btn);\r\n            }\r\n        });\r\n        form.addEventListener('input', async(e) => {\r\n            let input = e.target.closest('.forms-fieldmanager input');\r\n            if (input) {\r\n                // If the input is a field name, we need to save the fields.\r\n                await this.saveFields();\r\n            }\r\n            let select = e.target.closest('.forms-fieldmanager select');\r\n            if (select) {\r\n                // If the select is a field type, we need to save the fields.\r\n                await this.saveFields();\r\n            }\r\n            let requiredButton = e.target.closest('input[name=\"fieldrequired\"]');\r\n            if (requiredButton) {\r\n                // If the required button is clicked, we need to save the fields.\r\n                await this.saveFields();\r\n            }\r\n            let tabName = e.target.closest('input[data-action=\"update-tab-name\"]');\r\n            if (tabName) {\r\n                // If the tab name input is changed, we need to save the fields.\r\n                await this.saveFields();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Actions to be performed when a button is clicked.\r\n     * @param {HTMLElement} btn The button that was clicked.\r\n     * @returns {Promise<void>} A promise that resolves when the action is complete.\r\n     */\r\n    async actions(btn) {\r\n        const actionMap = {\r\n            'add-field': this.addField,\r\n            'save-fields': this.saveFields,\r\n            'delete-field': this.deleteField,\r\n            'add-tab': this.addTab,\r\n            'remove-tab': this.removeTab,\r\n        };\r\n        const action = btn.dataset.action;\r\n        if (actionMap[action]) {\r\n            actionMap[action].call(this, btn);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the configuration for the field manager.\r\n     * @param {Object} fields The configuration object.\r\n     */\r\n    setConfig(fields) {\r\n        const config = document.querySelector('[name=\"assignsubmission_forms_config\"]');\r\n        if (!config) {\r\n            throw new Error('Configuration input not found.');\r\n        }\r\n        // Convert the fields array to a JSON string and set it as the value of the config input.\r\n        config.value = JSON.stringify(fields);\r\n    }\r\n\r\n    /**\r\n     * Get the configuration for the field manager.\r\n     * @returns {Object} fields The configuration object.\r\n     */\r\n    getConfig() {\r\n        const config = document.querySelector('[name=\"assignsubmission_forms_config\"]');\r\n        if (!config) {\r\n            throw new Error('Configuration input not found.');\r\n        }\r\n        if (!config.value) {\r\n            this.addField(); // If no config value, add a new field.\r\n            return;\r\n        }\r\n        // Parse the JSON string from the config input and return it as an object.\r\n        const fields = JSON.parse(config.value);\r\n        if (!fields || !Array.isArray(fields) || fields.length === 0) {\r\n            this.addField();\r\n        } else {\r\n            this.fields = fields;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fetch the field data from the UI\r\n     */\r\n    getFieldsFromUI() {\r\n        const rootElement = document.querySelector('[data-region=\"forms-fieldmanager\"]');\r\n        if (!rootElement) {\r\n            throw new Error('FieldManager root element not found.');\r\n        }\r\n        const fieldCards = rootElement.querySelectorAll('[data-region=\"field\"]');\r\n        if (fieldCards.length === 0) {\r\n            return []; // No fields found, return an empty array.\r\n        }\r\n        // Collect the fields data from the UI.\r\n        const fields = [];\r\n        fieldCards.forEach((card) => {\r\n            const fieldid = card.dataset.fieldid;\r\n            const nameInput = card.querySelector('input[name=\"fieldname\"]');\r\n            const typeSelect = card.querySelector('select[name=\"fieldtype\"]');\r\n            const requiredSelect = card.querySelector('input[name=\"fieldrequired\"]');\r\n            const tab = rootElement.querySelector('[data-tab-id=\"' + fieldid + '\"]');\r\n            if (nameInput && typeSelect) {\r\n                const field = {\r\n                    id: fieldid ? parseInt(fieldid, 10) : null,\r\n                    name: nameInput.value.trim(),\r\n                    type: typeSelect.value,\r\n                    deleted: card.dataset.deleted == 1 ? true : false,\r\n                    required: requiredSelect.checked == true ? true : false,\r\n                };\r\n                if (tab) {\r\n                    const tabNameInput = tab.querySelector('input[data-action=\"update-tab-name\"]');\r\n                    if (tabNameInput) {\r\n                        field.tabs = {\r\n                            id: field.id,\r\n                            name: tabNameInput.value.trim()\r\n                        };\r\n                    }\r\n                }\r\n                fields.push(field);\r\n            } else {\r\n                throw new Error('Field name or type input not found in the field card.');\r\n            }\r\n        });\r\n        if (fields.length === 0) {\r\n            throw new Error('No valid fields found in the UI.');\r\n        }\r\n        return fields;\r\n    }\r\n\r\n    /**\r\n     * Saves the fields to the forms repository.\r\n     * @returns {Promise<void>} A promise that resolves when the fields are saved.\r\n     */\r\n    async saveFields() {\r\n        const rootElement = document.querySelector('[data-region=\"forms-fieldmanager\"]');\r\n        if (!rootElement) {\r\n            throw new Error('FieldManager root element not found.');\r\n        }\r\n        this.fields = this.getFieldsFromUI();\r\n        this.setConfig(this.fields); // Set the configuration with the current fields.\r\n        return; // No need to save fields if assignment ID is -1.\r\n    }\r\n\r\n    /**\r\n     * Adds a new field to the forms repository.\r\n     * @returns {Promise<void>} A promise that resolves when the field is added.\r\n     */\r\n    async addField() {\r\n        await this.saveFields(); // Save existing fields before adding a new one.\r\n        const newField = {\r\n            name: '',\r\n            type: 'textarea',\r\n        };\r\n\r\n        this.fields.push(newField);\r\n        this.renderFields();\r\n    }\r\n\r\n    /**\r\n     * Deletes a field from the forms repository.\r\n     * @param {HTMLElement} btn The button that was clicked to delete the field.\r\n     * @returns {Promise<void>} A promise that resolves when the field is deleted.\r\n     */\r\n    async deleteField(btn) {\r\n        const fieldCard = btn.closest('[data-region=\"field\"]');\r\n        if (!fieldCard) {\r\n            throw new Error('Field card not found.');\r\n        }\r\n        const fieldId = fieldCard.dataset.fieldid;\r\n        if (!fieldId) {\r\n            throw new Error('Field ID not found.');\r\n        }\r\n\r\n        // Remove the field from the fields array.\r\n        this.fields = this.fields.filter(field => field.id !== parseInt(fieldId, 10));\r\n        // Re-render the fields.\r\n        await this.renderFields();\r\n    }\r\n\r\n    /**\r\n     * Add a tab to separate the fields\r\n     * @param {HTMLElement} btn The button that was clicked to add the tab.\r\n     * @returns {Promise<void>} A promise that resolves when the tab is added.\r\n     */\r\n    async addTab(btn) {\r\n        const fieldCard = btn.closest('[data-region=\"field\"]');\r\n        if (!fieldCard) {\r\n            throw new Error('Field card not found.');\r\n        }\r\n        const fieldId = fieldCard.dataset.fieldid;\r\n        if (!fieldId) {\r\n            throw new Error('Field ID not found.');\r\n        }\r\n\r\n        const fieldIndex = this.fields.findIndex(field => field.id === parseInt(fieldId, 10));\r\n        if (fieldIndex === -1) {\r\n            throw new Error('Field not found in the fields array.');\r\n        }\r\n        const field = this.fields[fieldIndex];\r\n        field.tabs = field.tabs || [];\r\n        field.tabs.push({\r\n            id: fieldId,\r\n            name: 'New Section',\r\n        });\r\n        await this.renderFields();\r\n    }\r\n\r\n    /**\r\n     * Remove a tab from a field.\r\n     * @param {HTMLElement} btn The button that was clicked to remove the tab.\r\n     * @returns {Promise<void>} A promise that resolves when the tab is removed.\r\n     */\r\n    async removeTab(btn) {\r\n\r\n        const fieldId = btn.dataset.fieldid;\r\n        if (!fieldId) {\r\n            throw new Error('Field ID not found.');\r\n        }\r\n\r\n        const fieldIndex = this.fields.findIndex(field => field.id === parseInt(fieldId, 10));\r\n        if (fieldIndex === -1) {\r\n            throw new Error('Field not found in the fields array.');\r\n        }\r\n        const field = this.fields[fieldIndex];\r\n        field.tabs = [];\r\n        await this.renderFields();\r\n    }\r\n\r\n    /**\r\n     * Parse the fetched fields data, add the fieldtypes to each field and set the selected type.\r\n     * @returns {Promise<void>} A promise that resolves when the fields are parsed.\r\n     */\r\n    async parseFields() {\r\n        if (this.fields.length == 0) {\r\n            this.getConfig();\r\n        }\r\n        let fieldcount = 0;\r\n        // Create a copy of the fieldtypes to avoid modifying the original array.\r\n        this.fields.forEach((field) => {\r\n            field.id = ++fieldcount; // Assign a unique ID to each field.\r\n            const fieldtypes = this.fieldtypes.map(type => structuredClone(type));\r\n            // Add the selected attribute to the fieldtypes.\r\n            fieldtypes.forEach((type) => {\r\n                type.selected = type.name === field.type;\r\n            });\r\n            if (!fieldtypes.some(type => type.name === field.type)) {\r\n                fieldtypes[0].selected = true;\r\n            }\r\n            field.fieldtypes = fieldtypes;\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Renders the fields\r\n     */\r\n    async renderFields() {\r\n        await this.parseFields();\r\n        const rootElement = document.querySelector('[data-region=\"forms-fieldmanager\"] [data-region=\"fields-container\"]');\r\n        if (!rootElement) {\r\n            throw new Error('FieldManager root element not found.');\r\n        }\r\n\r\n        const {html, js} = await Templates.renderForPromise('assignsubmission_forms/fields', {\r\n            fields: this.fields,\r\n        });\r\n        Templates.replaceNodeContents(rootElement, html, js);\r\n    }\r\n}\r\n\r\nnew FieldManager();\r\n"],"names":["e","_templates","__esModule","default","fields","fieldtypes","constructor","rootElement","document","querySelector","form","fieldtypesInput","Error","this","JSON","parse","value","message","renderFields","addEventListener","btn","target","closest","preventDefault","actions","async","saveFields","actionMap","addField","deleteField","addTab","removeTab","action","dataset","call","setConfig","config","stringify","getConfig","Array","isArray","length","getFieldsFromUI","fieldCards","querySelectorAll","forEach","card","fieldid","nameInput","typeSelect","requiredSelect","tab","field","id","parseInt","name","trim","type","deleted","required","checked","tabNameInput","tabs","push","fieldCard","fieldId","filter","fieldIndex","findIndex","parseFields","fieldcount","map","structuredClone","selected","some","html","js","Templates","renderForPromise","replaceNodeContents"],"mappings":"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"}